(function ($) {
    var observableFactoryKey = "__observableFactory__";  // TODO: Uniquify further?

    $.observable = function (data, options) {
        var factory = $.data(data, observableFactoryKey),
			useDefault = options && !!options.useDefault;
        // TODO: "useDefault" is used by data stores/caches when they are making changes to their
        // own cache -- changes that they don't want to interpret as an app-specified data change.
        // Consider a different design here that achieves the same effect.

        if (factory && !useDefault) {
            return factory(data);
        } else {
            return createObservable(data);
        }
    };

    $.observable.track = function (data, options) {
        if (options && $.data(data, observableFactoryKey)) {
            throw "Observable already tracked for this data.";
        }

        // TODO: Should there be an explicit "untrack" to remove the extension?
        var factory = !options ? null : function (data) {
            var observable = createObservable(data);
            observable._beforeChange = options.beforeChange;
            observable._afterChange = options.afterChange;
            observable._afterEvent = options.afterEvent;
            return observable;
        };

        $.data(data, observableFactoryKey, factory);
    };

    var splice = [].splice;

    function ObjectObservable(data) {
        if (!this.data) {
            return new ObjectObservable(data);
        }

        this._data = data;
        return this;
    }

    $.observable.Object = ObjectObservable;

    ObjectObservable.prototype = {
        _data: null,

        data: function () {
            return this._data;
        },

        setProperty: function (path, value) {
            if ($.isArray(path)) {
                // This is the array format generated by serializeArray.
                // TODO: We've discussed an "objectchange" event to capture all N property updates here.
                for (var i = 0, l = path.length; i < l; i++) {
                    var pair = path[i];
                    this.setProperty(pair.name, pair.value);
                }
            } else if (typeof (path) === "object") {
                // Object representation where property name is path and property value is value.
                // TODO: We've discussed an "objectchange" event to capture all N property updates here.
                for (var key in path) {
                    this.setProperty(key, path[key]);
                }
            } else {
                // Simple single property case.
                var setter, property,
					object = this._data,
					leaf = getLeafObject(object, path);

                path = leaf[1];
                leaf = leaf[0];
                if (leaf) {
                    property = leaf[path];
                    if ($.isFunction(property)) {
                        // Case of property setter/getter - with convention that property() is getter and property( value ) is setter
                        setter = property;
                        property = property.call(leaf); //get
                    }

                    var eventData = { path: path, value: value },
						changeFn = function (eventData) {
						    if (setter) {
						        setter.call(leaf, value);  //set
						        eventData.value = setter.call(leaf); //get updated value
						    } else {
						        leaf[path] = value;
						    }
						    return eventData;
						};
                    changeDataAndTriggerEvents(this, changeFn, $(leaf), "propertyChange", eventData);
                }
            }
            return this;
        }
    };

    function getLeafObject(object, path) {
        if (object && path) {
            var parts = path.split(".");

            path = parts.pop();
            while (object && parts.length) {
                object = object[parts.shift()];
            }
            return [object, path];
        }
        return [];
    }

    function ArrayObservable(data) {
        if (!this.data) {
            return new ArrayObservable(data);
        }

        this._data = data;
        return this;
    }

    function validateIndex(index) {
        if (typeof index !== "number" || index < 0) {
            throw "Invalid index.";
        }
    }

    $.observable.Array = ArrayObservable;

    ArrayObservable.prototype = {
        _data: null,

        data: function () {
            return this._data;
        },

        insert: function (index, data) {
            validateIndex(index);

            if (arguments.length > 1) {
                data = $.isArray(data) ? data : [data];  // TODO: Clone array here?
                // data can be a single item (including a null/undefined value) or an array of items.

                if (data.length > 0) {
                    var that = this,
						changeFn = function () {
						    splice.apply(that._data, [index, 0].concat(data));
						},
						eventData = { change: "insert", index: index, items: data };
                    this._changeDataAndTriggerEvents(changeFn, eventData);
                }
            }

            return this;
        },

        remove: function (index, numToRemove) {
            validateIndex(index);

            numToRemove = (numToRemove === undefined || numToRemove === null) ? 1 : numToRemove;
            if (numToRemove) {
                var that = this,
					changeFn = function () {
					    that._data.splice(index, numToRemove);
					},
					items = this._data.slice(index, index + numToRemove),
					eventData = { change: "remove", index: index, items: items };
                this._changeDataAndTriggerEvents(changeFn, eventData);
            }

            return this;
        },

        move: function (oldIndex, newIndex, numToMove) {
            validateIndex(oldIndex);
            validateIndex(newIndex);

            numToMove = (numToMove === undefined || numToMove === null) ? 1 : numToMove;
            if (numToMove) {
                var that = this,
					items = this._data.slice(oldIndex, oldIndex + numToMove),
					changeFn = function () {
					    that._data.splice(oldIndex, numToMove);
					    that._data.splice.apply(that._data, [newIndex, 0].concat(items));
					},
					eventData = { change: "move", oldIndex: oldIndex, newIndex: newIndex, items: items };
                this._changeDataAndTriggerEvents(changeFn, eventData);
            }

            return this;
        },

        refresh: function (newItems) {
            var that = this,
				changeFn = function () {
				    that._data.splice.apply(that._data, [0, that._data.length].concat(newItems));
				},
				eventData = { change: "refresh", oldItems: this._data.slice(0), newItems: newItems };
            this._changeDataAndTriggerEvents(changeFn, eventData);
            return this;
        },

        _changeDataAndTriggerEvents: function (changeFn, eventData) {
            changeDataAndTriggerEvents(this, changeFn, $([this._data]), "arrayChange", eventData);
        }
    };

    function createObservable(data) {
        return $.isArray(data) ?
            new ArrayObservable(data) : 
            new ObjectObservable(data);
        // To handle non-Array-typed collections, we could allow developers to
        // customize this logic.
    }

    function changeDataAndTriggerEvents(observable, change, $target, type, data) {
        var target = $target[0];

        if (observable._beforeChange) {
            observable._beforeChange.call(observable, target, type, data);
        }

        var newData = change(data);
        if (newData) {
            data = newData;
        }

        if (observable._afterChange) {
            observable._afterChange.call(observable, target, type, data);
        }

        $target.triggerHandler(type, data);

        if (observable._afterEvent) {
            observable._afterEvent.call(observable, target, type, data);
        }
    }

})(jQuery);

